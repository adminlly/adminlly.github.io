
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>JavaScript 描述,语法 | 李刘玉的博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="李刘玉">
    
    <meta name="description" content="JavaScript
JavaScript的组成

JavaScript 由以下三部分组成：
ECMAScript（核心）：JavaScript 语言基础
DOM（文档对象模型）：规定了访问HTML和XML的接口
BOM（浏览器对象模型）：提供了浏览器窗口之间进行交互的对象和方法



JS的基本数">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/pacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/pacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="李刘玉的博客" title="李刘玉的博客"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="李刘玉的博客">李刘玉的博客</a></h1>
				<h2 class="blog-motto">胆小认生，踏实认真</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					
						<li><a href="/">主页</a></li>
					
						<li><a href="/archives">档案</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:adminlly.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/05/10/JavaScript/" title="JavaScript 描述,语法" itemprop="url">JavaScript 描述,语法</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://adminlly.github.io" title="李刘玉">李刘玉</a>
    </p>
  <p class="article-time">
    <time datetime="2017-05-09T16:00:00.000Z" itemprop="datePublished">2017-05-10</time>
    Updated:<time datetime="2017-10-26T14:57:32.436Z" itemprop="dateModified">2017-10-26</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">Contents</strong>
		<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript"><span class="toc-number">1.</span> <span class="toc-text">JavaScript</span></a></li></ol>
		</div>
		
		<h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><hr>
<p><strong>JavaScript的组成</strong></p>
<ul>
<li>JavaScript 由以下三部分组成：<ul>
<li>ECMAScript（核心）：JavaScript 语言基础</li>
<li>DOM（文档对象模型）：规定了访问HTML和XML的接口</li>
<li>BOM（浏览器对象模型）：提供了浏览器窗口之间进行交互的对象和方法</li>
</ul>
</li>
</ul>
<p><strong>JS的基本数据类型和引用数据类型</strong></p>
<ul>
<li>基本数据类型：undefined、null、boolean、number、string、symbol</li>
<li>引用数据类型：object、array、function</li>
</ul>
<p><strong>检测浏览器版本版本有哪些方式？</strong></p>
<ul>
<li>根据 navigator.userAgent   //  UA.toLowerCase().indexOf(‘chrome’)</li>
<li>根据 window 对象的成员       // ‘ActiveXObject’ in window</li>
</ul>
<p><strong>介绍JS有哪些内置对象？</strong></p>
<ul>
<li>数据封装类对象：Object、Array、Boolean、Number、String</li>
<li>其他对象：Function、Arguments、Math、Date、RegExp、Error</li>
<li>ES6新增对象：Symbol、Map、Set、Promises、Proxy、Reflect</li>
</ul>
<p><strong>说几条写JavaScript的基本规范？</strong></p>
<ul>
<li>代码缩进，建议使用“四个空格”缩进</li>
<li>代码段使用花括号{}包裹</li>
<li>语句结束使用分号;</li>
<li>变量和函数在使用前进行声明</li>
<li>以大写字母开头命名构造函数，全大写命名常量</li>
<li>规范定义JSON对象，补全双引号</li>
<li>用{}和[]声明对象和数组</li>
</ul>
<p><strong>如何编写高性能的JavaScript？</strong></p>
<ul>
<li>遵循严格模式：”use strict”;</li>
<li>将js脚本放在页面底部，加快渲染页面</li>
<li>将js脚本将脚本成组打包，减少请求</li>
<li>使用非阻塞方式下载js脚本</li>
<li>尽量使用局部变量来保存全局变量</li>
<li>尽量减少使用闭包</li>
<li>使用 window 对象属性方法时，省略 window</li>
<li>尽量减少对象成员嵌套</li>
<li>缓存 DOM 节点的访问</li>
<li>通过避免使用 eval() 和 Function() 构造器</li>
<li>给 setTimeout() 和 setInterval() 传递函数而不是字符串作为参数</li>
<li>尽量使用直接量创建对象和数组</li>
<li>最小化重绘(repaint)和回流(reflow)</li>
</ul>
<p><strong>描述浏览器的渲染过程，DOM树和渲染树的区别？</strong></p>
<ul>
<li><p>浏览器的渲染过程：</p>
<ul>
<li>解析HTML构建 DOM(DOM树)，并行请求 css/image/js</li>
<li>CSS 文件下载完成，开始构建 CSSOM(CSS树)</li>
<li>CSSOM 构建结束后，和 DOM 一起生成 Render Tree(渲染树)</li>
<li>布局(Layout)：计算出每个节点在屏幕中的位置</li>
<li>显示(Painting)：通过显卡把页面画到屏幕上</li>
</ul>
</li>
<li><p>DOM树 和 渲染树 的区别：</p>
<ul>
<li>DOM树与HTML标签一一对应，包括head和隐藏元素</li>
<li>渲染树不包括head和隐藏元素，大段文本的每一个行都是独立节点，每一个节点都有对应的css属性</li>
</ul>
</li>
</ul>
<p><strong>重绘和回流（重排）的区别和关系？</strong></p>
<ul>
<li>重绘：当渲染树中的元素外观（如：颜色）发生改变，不影响布局时，产生重绘</li>
<li>回流：当渲染树中的元素的布局（如：尺寸、位置、隐藏/状态状态）发生改变时，产生重绘回流</li>
<li>注意：JS获取Layout属性值（如：offsetLeft、scrollTop、getComputedStyle等）也会引起回流。因为浏览器需要通过回流计算最新值</li>
<li>回流必将引起重绘，而重绘不一定会引起回流</li>
</ul>
<p><strong>如何最小化重绘(repaint)和回流(reflow)？</strong></p>
<ul>
<li>需要要对元素进行复杂的操作时，可以先隐藏(display:”none”)，操作完成后再显示</li>
<li>需要创建多个DOM节点时，使用DocumentFragment创建完后一次性的加入document</li>
<li>缓存Layout属性值，如：var left = elem.offsetLeft; 这样，多次使用 left 只产生一次回流</li>
<li>尽量避免用table布局（table元素一旦触发回流就会导致table里所有的其它元素回流）</li>
<li>避免使用css表达式(expression)，因为每次调用都会重新计算值（包括加载页面）</li>
<li>尽量使用 css 属性简写，如：用 border 代替 border-width, border-style, border-color</li>
<li>批量修改元素样式：elem.className 和 elem.style.cssText 代替 elem.style.xxx</li>
</ul>
<p><strong>script 的位置是否会影响首屏显示时间？</strong></p>
<ul>
<li>在解析 HTML 生成 DOM 过程中，js 文件的下载是并行的，不需要 DOM 处理到 script 节点。因此，script的位置不影响首屏显示的开始时间。</li>
<li>浏览器解析 HTML 是自上而下的线性过程，script作为 HTML 的一部分同样遵循这个原则</li>
<li>因此，script 会延迟 DomContentLoad，只显示其上部分首屏内容，从而影响首屏显示的完成时间</li>
</ul>
<p><strong>解释JavaScript中的作用域与变量声明提升？</strong></p>
<ul>
<li><p>JavaScript作用域：</p>
<ul>
<li>在Java、C等语言中，作用域为for语句、if语句或{}内的一块区域，称为作用域；</li>
<li>而在 JavaScript 中，作用域为function(){}内的区域，称为函数作用域。</li>
</ul>
</li>
<li><p>JavaScript变量声明提升：</p>
<ul>
<li>在JavaScript中，函数声明与变量声明经常被JavaScript引擎隐式地提升到当前作用域的顶部。</li>
<li>声明语句中的赋值部分并不会被提升，只有名称被提升</li>
<li>函数声明的优先级高于变量，如果变量名跟函数名相同且未赋值，则函数声明会覆盖变量声明</li>
<li>如果函数有多个同名参数，那么最后一个参数（即使没有定义）会覆盖前面的同名参数</li>
</ul>
</li>
</ul>
<p><strong>介绍JavaScript的原型，原型链？有什么特点？</strong></p>
<ul>
<li><p>原型：</p>
<ul>
<li>JavaScript的所有对象中都包含了一个 [<strong>proto</strong>] 内部属性，这个属性所对应的就是该对象的原型</li>
<li>JavaScript的函数对象，除了原型 [<strong>proto</strong>] 之外，还预置了 prototype 属性</li>
<li>当函数对象作为构造函数创建实例时，该 prototype 属性值将被作为实例对象的原型 [<strong>proto</strong>]。</li>
</ul>
</li>
<li><p>原型链：</p>
<ul>
<li>当一个对象调用的属性/方法自身不存在时，就会去自己 [<strong>proto</strong>] 关联的前辈 prototype 对象上去找</li>
<li>如果没找到，就会去该 prototype 原型 [<strong>proto</strong>] 关联的前辈 prototype 去找。依次类推，直到找到属性/方法或 undefined 为止。从而形成了所谓的“原型链”</li>
</ul>
</li>
</ul>
<ul>
<li>原型特点：<ul>
<li>JavaScript对象是通过引用来传递的，当修改原型时，与之相关的对象也会继承这一改变</li>
</ul>
</li>
</ul>
<p><strong>JavaScript有几种类型的值？，你能画一下他们的内存图吗</strong></p>
<ul>
<li>原始数据类型（Undefined，Null，Boolean，Number、String）– 栈</li>
<li>引用数据类型（对象、数组和函数）– 堆</li>
<li>两种类型的区别是：存储位置不同：</li>
<li>原始数据类型是直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据；</li>
<li>引用数据类型存储在堆(heap)中的对象，占据空间大、大小不固定，如果存储在栈中，将会影响程序运行的性能；</li>
<li>引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。</li>
<li>当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</li>
</ul>
<p><strong>JavaScript如何实现一个类，怎么实例化这个类？</strong></p>
<ul>
<li>构造函数法（this + prototype） – 用 new 关键字 生成实例对象<ul>
<li>缺点：用到了 this 和 prototype，编写复杂，可读性差</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Mobile</span>(<span class="params">name, price</span>)</span>&#123;</div><div class="line">   <span class="keyword">this</span>.name = name;</div><div class="line">   <span class="keyword">this</span>.price = price;</div><div class="line"> &#125;</div><div class="line"> Mobile.prototype.sell = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name + <span class="string">"，售价 $"</span> + <span class="keyword">this</span>.price);</div><div class="line"> &#125;</div><div class="line"> <span class="keyword">var</span> iPhone7 = <span class="keyword">new</span> Mobile(<span class="string">"iPhone7"</span>, <span class="number">1000</span>);</div><div class="line"> iPhone7.sell();</div></pre></td></tr></table></figure>
<ul>
<li>Object.create 法 – 用 Object.create() 生成实例对象</li>
<li>缺点：不能实现私有属性和私有方法，实例对象之间也不能共享数据</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Person = &#123;</div><div class="line">    firstname: <span class="string">"Mark"</span>,</div><div class="line">    lastname: <span class="string">"Yun"</span>,</div><div class="line">    age: <span class="number">25</span>,</div><div class="line">    introduce: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(<span class="string">'I am '</span> + Person.firstname + <span class="string">' '</span> + Person.lastname);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = <span class="built_in">Object</span>.create(Person);</div><div class="line">person.introduce();</div><div class="line"></div><div class="line"><span class="comment">// Object.create 要求 IE9+，低版本浏览器可以自行部署：</span></div><div class="line"><span class="keyword">if</span> (!<span class="built_in">Object</span>.create) &#123;</div><div class="line">　   <span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123;</div><div class="line">　　　 <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">　　　 F.prototype = o;</div><div class="line">　　　 <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">　　&#125;;</div><div class="line">　&#125;</div></pre></td></tr></table></figure>
<ul>
<li>极简主义法（消除 this 和 prototype） – 调用 createNew() 得到实例对象<ul>
<li>优点：容易理解，结构清晰优雅，符合传统的”面向对象编程”的构造</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Cat = &#123;</div><div class="line">  age: <span class="number">3</span>, <span class="comment">// 共享数据 -- 定义在类对象内，createNew() 外</span></div><div class="line">  createNew: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> cat = &#123;&#125;;</div><div class="line">    <span class="comment">// var cat = Animal.createNew(); // 继承 Animal 类</span></div><div class="line">    cat.name = <span class="string">"小咪"</span>;</div><div class="line">    <span class="keyword">var</span> sound = <span class="string">"喵喵喵"</span>; <span class="comment">// 私有属性--定义在 createNew() 内，输出对象外</span></div><div class="line">    cat.makeSound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      alert(sound);  <span class="comment">// 暴露私有属性</span></div><div class="line">    &#125;;</div><div class="line">    cat.changeAge = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">      Cat.age = num; <span class="comment">// 修改共享数据</span></div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> cat; <span class="comment">// 输出对象</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> cat = Cat.createNew();</div><div class="line">cat.makeSound();</div></pre></td></tr></table></figure>
<ul>
<li>ES6 语法糖 class – 用 new 关键字 生成实例对象      </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">     <span class="keyword">constructor</span>(x, y) &#123;</div><div class="line">       <span class="keyword">this</span>.x = x;</div><div class="line">       <span class="keyword">this</span>.y = y;</div><div class="line">     &#125;</div><div class="line">     toString() &#123;</div><div class="line">       <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> point = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">3</span>);</div></pre></td></tr></table></figure>
<p><strong>Javascript如何实现继承？</strong></p>
<ul>
<li>构造函数绑定：使用 call 或 apply 方法，将父对象的构造函数绑定在子对象上</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name,color</span>)</span>&#123;</div><div class="line"> 　Animal.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line"> 　<span class="keyword">this</span>.name = name;</div><div class="line"> 　<span class="keyword">this</span>.color = color;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>实例继承：将子对象的 prototype 指向父对象的一个实例     </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Cat.prototype = <span class="keyword">new</span> Animal();</div><div class="line">Cat.prototype.constructor = Cat;</div></pre></td></tr></table></figure>
<ul>
<li>拷贝继承：如果把父对象的所有属性和方法，拷贝进子对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">Child, Parent</span>) </span>&#123;</div><div class="line">  　　　<span class="keyword">var</span> p = Parent.prototype;</div><div class="line">  　　　<span class="keyword">var</span> c = Child.prototype;</div><div class="line">  　　　<span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) &#123;</div><div class="line">  　　　   c[i] = p[i];</div><div class="line">  　　　&#125;</div><div class="line">  　　　c.uber = p;</div><div class="line">  　 &#125;</div></pre></td></tr></table></figure>
<ul>
<li>原型继承：将子对象的 prototype 指向父对象的 prototype      </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">Child, Parent</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">  　F.prototype = Parent.prototype;</div><div class="line">  　Child.prototype = <span class="keyword">new</span> F();</div><div class="line">  　Child.prototype.constructor = Child;</div><div class="line">  　Child.uber = Parent.prototype;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>ES6 语法糖 extends：class ColorPoint extends Point {}</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</div><div class="line">   <span class="keyword">constructor</span>(x, y, color) &#123;</div><div class="line">      <span class="keyword">super</span>(x, y); <span class="comment">// 调用父类的constructor(x, y)</span></div><div class="line">      <span class="keyword">this</span>.color = color;</div><div class="line">   &#125;</div><div class="line">   toString() &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.color + <span class="string">' '</span> + <span class="keyword">super</span>.toString(); <span class="comment">// 调用父类的toString()</span></div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>Javascript作用链域?</strong></p>
<ul>
<li>全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节</li>
<li>如果当前作用域没有找到属性或方法，会向上层作用域查找，直至全局函数，这种形式就是作用域链</li>
</ul>
<p><strong>谈谈this对象的理解</strong></p>
<ul>
<li>this 总是指向函数的直接调用者</li>
<li>如果有 new 关键字，this 指向 new 出来的实例对象</li>
<li>在事件中，this指向触发这个事件的对象</li>
<li>IE下 attachEvent 中的this总是指向全局对象Window</li>
</ul>
<p><strong>eval是做什么的？</strong></p>
<p><strong>eval的功能是把对应的字符串解析成JS代码并运行</strong></p>
<ul>
<li>应该避免使用eval，不安全，非常耗性能（先解析成js语句，再执行）</li>
<li>由JSON字符串转换为JSON对象的时候可以用 eval(‘(‘+ str +’)’);</li>
</ul>
<p><strong>什么是 Window 对象? 什么是 Document 对象?</strong></p>
<ul>
<li>Window 对象表示当前浏览器的窗口，是JavaScript的顶级对象。</li>
<li>我们创建的所有对象、函数、变量都是 Window 对象的成员。</li>
<li>Window 对象的方法和属性是在全局范围内有效的。</li>
<li>Document 对象是 HTML 文档的根节点与所有其他节点（元素节点，文本节点，属性节点, 注释节点）</li>
<li>Document 对象使我们可以通过脚本对 HTML 页面中的所有元素进行访问</li>
<li>Document 对象是 Window 对象的一部分，可通过 window.document 属性对其进行访问</li>
</ul>
<p><strong>介绍 DOM 的发展</strong></p>
<ul>
<li>DOM：文档对象模型（Document Object Model），定义了访问HTML和XML文档的标准，与编程语言及平台无关</li>
<li>DOM0：提供了查询和操作Web文档的内容API。未形成标准，实现混乱。如：document.forms[‘login’]</li>
<li>DOM1：W3C提出标准化的DOM，简化了对文档中任意部分的访问和操作。如：JavaScript中的Document对象</li>
<li>DOM2：原来DOM基础上扩充了鼠标事件等细分模块，增加了对CSS的支持。如：getComputedStyle(elem, pseudo)</li>
<li>DOM3：增加了XPath模块和加载与保存（Load and Save）模块。如：XPathEvaluator</li>
</ul>
<p><strong>介绍DOM0，DOM2，DOM3事件处理方式区别</strong></p>
<ul>
<li>DOM0级事件处理方式：<ul>
<li><code>btn.onclick = func;</code></li>
<li><code>btn.onclick = null;</code></li>
</ul>
</li>
<li>DOM2级事件处理方式：<ul>
<li><code>btn.addEventListener(&#39;click&#39;, func, false);</code></li>
<li><code>btn.removeEventListener(&#39;click&#39;, func, false);</code></li>
<li><code>btn.attachEvent(&quot;onclick&quot;, func);</code></li>
<li><code>btn.detachEvent(&quot;onclick&quot;, func);</code></li>
</ul>
</li>
<li>DOM3级事件处理方式：<ul>
<li><code>eventUtil.addListener(input, &quot;textInput&quot;, func);</code></li>
<li><code>eventUtil</code> 是自定义对象，<code>textInput</code> 是DOM3级事件</li>
</ul>
</li>
</ul>
<p><strong>事件的三个阶段</strong></p>
<ul>
<li>捕获、目标、冒泡</li>
</ul>
<p><strong>介绍事件“捕获”和“冒泡”执行顺序和事件的执行次数？</strong></p>
<ul>
<li>按照W3C标准的事件：首是进入捕获阶段，直到达到目标元素，再进入冒泡阶段</li>
<li>事件执行次数（DOM2-addEventListener）：元素上绑定事件的个数<ul>
<li>注意1：前提是事件被确实触发</li>
<li>注意2：事件绑定几次就算几个事件，即使类型和功能完全一样也不会“覆盖”</li>
</ul>
</li>
<li>事件执行顺序：判断的关键是否目标元素<ul>
<li>非目标元素：根据W3C的标准执行：捕获-&gt;目标元素-&gt;冒泡（不依据事件绑定顺序）</li>
<li>目标元素：依据事件绑定顺序：先绑定的事件先执行（不依据捕获冒泡标准）</li>
<li>最终顺序：父元素捕获-&gt;目标元素事件1-&gt;目标元素事件2-&gt;子元素捕获-&gt;子元素冒泡-&gt;父元素冒泡</li>
<li>注意：子元素事件执行前提    事件确实“落”到子元素布局区域上，而不是简单的具有嵌套关系</li>
</ul>
</li>
</ul>
<p><strong>在一个DOM上同时绑定两个点击事件：一个用捕获，一个用冒泡。事件会执行几次，先执行冒泡还是捕获？</strong></p>
<ul>
<li>该DOM上的事件如果被触发，会执行两次（执行次数等于绑定次数）</li>
<li>如果该DOM是目标元素，则按事件绑定顺序执行，不区分冒泡/捕获</li>
<li>如果该DOM是处于事件流中的非目标元素，则先执行捕获，后执行冒泡</li>
</ul>
<p><strong>事件的代理/委托</strong></p>
<ul>
<li>事件委托是指将事件绑定目标元素的到父元素上，利用冒泡机制触发该事件<ul>
<li>优点：<ul>
<li>可以减少事件注册，节省大量内存占用</li>
<li>可以将事件应用于动态添加的子元素上</li>
</ul>
</li>
<li>缺点：<br>使用不当会造成事件在不应该触发时触发</li>
<li>示例：</li>
</ul>
</li>
</ul>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ulEl.addEventListener(<span class="string">'click'</span>, function(e)&#123;</div><div class="line">    var <span class="keyword">target</span> = event.<span class="keyword">target</span> || event.srcElement;</div><div class="line">    <span class="keyword">if</span>(!!<span class="keyword">target</span> &amp;&amp; <span class="keyword">target</span>.nodeName.toUpperCase() === <span class="string">"LI"</span>)&#123;</div><div class="line">        console.log(<span class="keyword">target</span>.innerHTML);</div><div class="line">    &#125;</div><div class="line">&#125;, <span class="keyword">false</span>);</div></pre></td></tr></table></figure>
<p><strong>IE与火狐的事件机制有什么区别？ 如何阻止冒泡？</strong></p>
<ul>
<li>IE只事件冒泡，不支持事件捕获；火狐同时支持件冒泡和事件捕获</li>
</ul>
<p><strong>IE的事件处理和W3C的事件处理有哪些区别？</strong></p>
<ul>
<li><p>绑定事件</p>
<ul>
<li>W3C: targetEl.addEventListener(‘click’, handler, false);</li>
<li>IE: targetEl.attachEvent(‘onclick’, handler);</li>
</ul>
</li>
<li><p>删除事件</p>
<ul>
<li>W3C: targetEl.removeEventListener(‘click’, handler, false);</li>
<li>IE: targetEl.detachEvent(event, handler);</li>
</ul>
</li>
<li><p>事件对象</p>
<ul>
<li>W3C: var e = arguments.callee.caller.arguments[0]</li>
<li>IE: window.event</li>
</ul>
</li>
<li><p>事件目标</p>
<ul>
<li>W3C: e.target</li>
<li>IE: window.event.srcElement</li>
</ul>
</li>
<li><p>阻止事件默认行为</p>
<ul>
<li>W3C: window.event.cancelBubble = true</li>
<li>IE: window.event.returnValue = false</li>
</ul>
</li>
<li><p>阻止事件传播</p>
<ul>
<li>W3C: e.stopPropagation()</li>
<li>IE: window.event</li>
</ul>
</li>
</ul>
<p><strong>W3C事件的 target 与 currentTarget 的区别？</strong></p>
<ul>
<li>target 只会出现在事件流的目标阶段</li>
<li>currentTarget 可能出现在事件流的任何阶段</li>
<li>当事件流处在目标阶段时，二者的指向相同</li>
<li>当事件流处于捕获或冒泡阶段时：currentTarget 指向当前事件活动的对象(一般为父级)</li>
</ul>
<p><strong>如何派发事件(dispatchEvent)？（如何进行事件广播？）</strong></p>
<ul>
<li>W3C: 使用 dispatchEvent 方法</li>
<li>IE: 使用 fireEvent 方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fireEvent = <span class="function"><span class="keyword">function</span>(<span class="params">element, event</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.createEventObject)&#123;</div><div class="line">        <span class="keyword">var</span> mockEvent = <span class="built_in">document</span>.createEventObject();</div><div class="line">        <span class="keyword">return</span> element.fireEvent(<span class="string">'on'</span> + event, mockEvent)</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">var</span> mockEvent = <span class="built_in">document</span>.createEvent(<span class="string">'HTMLEvents'</span>);</div><div class="line">        mockEvent.initEvent(event, <span class="literal">true</span>, <span class="literal">true</span>);</div><div class="line">        <span class="keyword">return</span> !element.dispatchEvent(mockEvent);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>什么是函数节流？介绍一下应用场景和原理？</strong></p>
<ul>
<li><p>函数节流(throttle)是指阻止一个函数在很短时间间隔内连续调用。<br>只有当上一次函数执行后达到规定的时间间隔，才能进行下一次调用。<br>但要保证一个累计最小调用间隔（否则拖拽类的节流都将无连续效果）</p>
</li>
<li><p>函数节流用于 onresize, onscroll 等短时间内会多次触发的事件</p>
</li>
<li><p>函数节流的原理：使用定时器做时间节流。<br>当触发一个事件时，先用 setTimout 让这个事件延迟一小段时间再执行。<br>如果在这个时间间隔内又触发了事件，就 clearTimeout 原来的定时器，<br>再 setTimeout 一个新的定时器重复以上流程。</p>
</li>
<li><p>函数节流简单实现：</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">method, context</span>) </span>&#123;</div><div class="line">     clearTimeout(methor.tId);</div><div class="line">     method.tId = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">         method.call(context);</div><div class="line">     &#125;， <span class="number">100</span>); <span class="comment">// 两次调用至少间隔 100ms</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 调用</span></div><div class="line"><span class="built_in">window</span>.onresize = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    throttle(myFunc, <span class="built_in">window</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标”？</strong></p>
<ul>
<li>客户区坐标：鼠标指针在可视区中的水平坐标(clientX)和垂直坐标(clientY)</li>
<li>页面坐标：鼠标指针在页面布局中的水平坐标(pageX)和垂直坐标(pageY)</li>
<li>屏幕坐标：设备物理屏幕的水平坐标(screenX)和垂直坐标(screenY)</li>
</ul>
<p><strong>如何获得一个DOM元素的绝对位置？</strong></p>
<ul>
<li>elem.offsetLeft：返回元素相对于其定位父级左侧的距离</li>
<li>elem.offsetTop：返回元素相对于其定位父级顶部的距离</li>
<li>elem.getBoundingClientRect()：返回一个DOMRect对象，包含一组描述边框的只读属性，单位像素</li>
</ul>
<p><strong>分析 [‘1’, ‘2’, ‘3’].map(parseInt) 答案是多少？</strong></p>
<ul>
<li>答案:[1, NaN, NaN]</li>
</ul>
<ul>
<li>parseInt(string, radix) 第2个参数 radix 表示进制。省略 radix 或 radix = 0，则数字将以十进制解析</li>
<li>map 每次为 parseInt 传3个参数(elem, index, array)，其中 index 为数组索引</li>
<li>因此，map 遍历 [“1”, “2”, “3”]，相应 parseInt 接收参数如下</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">parseInt</span>(<span class="string">'1'</span>, <span class="number">0</span>);  <span class="comment">// 1</span></div><div class="line"><span class="built_in">parseInt</span>(<span class="string">'2'</span>, <span class="number">1</span>);  <span class="comment">// NaN</span></div><div class="line"><span class="built_in">parseInt</span>(<span class="string">'3'</span>, <span class="number">2</span>);  <span class="comment">// NaN</span></div></pre></td></tr></table></figure>
<ul>
<li>所以，parseInt 参数 radix 不合法，导致返回值为 NaN</li>
</ul>
<p><strong>new 操作符具体干了什么？</strong></p>
<ul>
<li>创建实例对象，this 变量引用该对象，同时还继承了构造函数的原型</li>
<li>属性和方法被加入到 this 引用的对象中</li>
<li>新创建的对象由 this 所引用，并且最后隐式的返回 this</li>
</ul>
<p><strong>用原生JavaScript的实现过什么功能吗？</strong></p>
<ul>
<li>封装选择器、调用第三方API、设置和获取样式</li>
</ul>
<p><strong>解释一下这段代码的意思吗？</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[].forEach.call($$(<span class="string">"*"</span>), <span class="function"><span class="keyword">function</span>(<span class="params">el</span>)</span>&#123;</div><div class="line">    el.style.outline = <span class="string">"1px solid #"</span> + (~~(<span class="built_in">Math</span>.random()*(<span class="number">1</span>&lt;&lt;<span class="number">24</span>))).toString(<span class="number">16</span>);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<ul>
<li>解释：获取页面所有的元素，遍历这些元素，为它们添加1像素随机颜色的轮廓(outline)</li>
<li><ol>
<li><code>$$(sel)</code> // $$函数被许多现代浏览器命令行支持，等价于 document.querySelectorAll(sel)</li>
</ol>
</li>
<li><ol>
<li><code>[].forEach.call(NodeLists)</code> // 使用 call 函数将数组遍历函数 forEach 应到节点元素列表</li>
</ol>
</li>
<li><ol>
<li><code>el.style.outline = &quot;1px solid #333&quot;</code> // 样式 outline 位于盒模型之外，不影响元素布局位置</li>
</ol>
</li>
<li><ol>
<li><code>(1&lt;&lt;24)</code> // parseInt(“ffffff”, 16) == 16777215 == 2^24 - 1 // 1&lt;&lt;24 == 2^24 == 16777216</li>
</ol>
</li>
<li><ol>
<li><code>Math.random()*(1&lt;&lt;24)</code> // 表示一个位于 0 到 16777216 之间的随机浮点数</li>
</ol>
</li>
<li><ol>
<li><code>~~Math.random()*(1&lt;&lt;24)</code> // <code>~~</code> 作用相当于 parseInt 取整</li>
</ol>
</li>
<li><ol>
<li><code>(~~(Math.random()*(1&lt;&lt;24))).toString(16)</code> // 转换为一个十六进制- </li>
</ol>
</li>
</ul>
<p><strong> JavaScript实现异步编程的方法？</strong></p>
<ul>
<li>回调函数</li>
<li>事件监听</li>
<li>发布/订阅</li>
<li>Promises对象</li>
<li>Async函数[ES7]</li>
</ul>
<p><strong>web开发中会话跟踪的方法有哪些</strong></p>
<ul>
<li>cookie</li>
<li>session</li>
<li>url重写</li>
<li>隐藏input</li>
<li>ip地址</li>
</ul>
<p><strong>介绍js的基本数据类型</strong></p>
<ul>
<li>Undefined、Null、Boolean、Number、String</li>
</ul>
<p><strong>介绍js有哪些内置对象？</strong></p>
<ul>
<li>Object 是 JavaScript 中所有对象的父对象</li>
<li>数据封装类对象：Object、Array、Boolean、Number 和 String</li>
<li>其他对象：Function、Arguments、Math、Date、RegExp、Error</li>
</ul>
<p><strong>说几条写JavaScript的基本规范？</strong></p>
<ul>
<li>不要在同一行声明多个变量</li>
<li>请使用 ===/!==来比较true/false或者数值</li>
<li>使用对象字面量替代new Array这种形式</li>
<li>不要使用全局函数</li>
<li>Switch语句必须带有default分支</li>
<li>函数不应该有时候有返回值，有时候没有返回值</li>
<li>If语句必须使用大括号</li>
<li>for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污</li>
</ul>
<p><strong>JavaScript原型，原型链 ? 有什么特点？</strong></p>
<ul>
<li>每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时</li>
<li>如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念</li>
<li>关系：<code>instance.constructor.prototype = instance.__proto__</code></li>
<li><p>特点：</p>
<ul>
<li>JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。</li>
</ul>
</li>
<li><p>当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的</p>
</li>
<li>就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象</li>
</ul>
<p><strong>JavaScript有几种类型的值？，你能画一下他们的内存图吗？</strong></p>
<ul>
<li>栈：原始数据类型（Undefined，Null，Boolean，Number、String） </li>
<li><p>堆：引用数据类型（对象、数组和函数）</p>
</li>
<li><p>两种类型的区别是：存储位置不同；</p>
</li>
<li>原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</li>
<li>引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其</li>
<li>在栈中的地址，取得地址后从堆中获得实体</li>
</ul>
<p><img src="https://camo.githubusercontent.com/d1947e624a0444d1032a85800013df487adc5550/687474703a2f2f7777772e77337363686f6f6c2e636f6d2e636e2f692f63745f6a735f76616c75652e676966" alt=""></p>
<p><strong>Javascript如何实现继承？</strong></p>
<ul>
<li>构造继承</li>
<li>原型继承</li>
<li>实例继承</li>
<li><p>拷贝继承</p>
</li>
<li><p>原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式</p>
</li>
</ul>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span><span class="params">()</span></span>&#123;</div><div class="line">       <span class="keyword">this</span>.name = <span class="string">'wang'</span>;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">function</span> <span class="title">Child</span><span class="params">()</span></span>&#123;</div><div class="line">       <span class="keyword">this</span>.age = <span class="number">28</span>;</div><div class="line">   &#125;</div><div class="line">   Child.prototype = <span class="keyword">new</span> Parent();<span class="comment">//继承了Parent，通过原型</span></div><div class="line"></div><div class="line">   <span class="keyword">var</span> demo = <span class="keyword">new</span> Child();</div><div class="line">   alert(demo.age);</div><div class="line">   alert(demo.name);<span class="comment">//得到被继承的属性</span></div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p><strong>javascript创建对象的几种方式？</strong></p>
<blockquote>
<p>javascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用</p>
</blockquote>
<ul>
<li>对象字面量的方式</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">person=&#123;<span class="string">firstname:</span><span class="string">"Mark"</span>,<span class="string">lastname:</span><span class="string">"Yun"</span>,<span class="string">age:</span><span class="number">25</span>,<span class="string">eyecolor:</span><span class="string">"black"</span>&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>用function来模拟无参的构造函数</li>
</ul>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="keyword">var</span> person=<span class="keyword">new</span> Person();<span class="comment">//定义一个function，如果使用new"实例化",该function可以看作是一个Class</span></div><div class="line">        person.name=<span class="string">"Mark"</span>;</div><div class="line">        person.age=<span class="string">"25"</span>;</div><div class="line">        person.work=<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</div><div class="line">        alert(person.name+<span class="string">" hello..."</span>);</div><div class="line">    &#125;</div><div class="line">person.work();</div></pre></td></tr></table></figure>
<ul>
<li>用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）</li>
</ul>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Pet</span><span class="params">(name,age,hobby)</span></span>&#123;</div><div class="line">       <span class="keyword">this</span>.name=name;<span class="comment">//this作用域：当前对象</span></div><div class="line">       <span class="keyword">this</span>.age=age;</div><div class="line">       <span class="keyword">this</span>.hobby=hobby;</div><div class="line">       <span class="keyword">this</span>.eat=<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</div><div class="line">          alert(<span class="string">"我叫"</span>+<span class="keyword">this</span>.name+<span class="string">",我喜欢"</span>+<span class="keyword">this</span>.hobby+<span class="string">",是个程序员"</span>);</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> maidou =<span class="keyword">new</span> Pet(<span class="string">"麦兜"</span>,<span class="number">25</span>,<span class="string">"coding"</span>);<span class="comment">//实例化、创建对象</span></div><div class="line">    maidou.eat();<span class="comment">//调用eat方法</span></div></pre></td></tr></table></figure>
<ul>
<li>用工厂方式来创建（内置对象）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> wcDog =<span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">     wcDog.name=<span class="string">"旺财"</span>;</div><div class="line">     wcDog.age=<span class="number">3</span>;</div><div class="line">     wcDog.work=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">       alert(<span class="string">"我是"</span>+wcDog.name+<span class="string">",汪汪汪......"</span>);</div><div class="line">     &#125;</div><div class="line">     wcDog.work();</div></pre></td></tr></table></figure>
<ul>
<li>用原型方式来创建</li>
</ul>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">     &#125;</div><div class="line">     Dog.prototype.name=<span class="string">"旺财"</span>;</div><div class="line">     Dog.prototype.eat=<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</div><div class="line">     alert(<span class="keyword">this</span>.name+<span class="string">"是个吃货"</span>);</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">var</span> wangcai =<span class="keyword">new</span> Dog();</div><div class="line">     wangcai.eat();</div></pre></td></tr></table></figure>
<ul>
<li>用混合方式来创建</li>
</ul>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span><span class="params">(name,price)</span></span>&#123;</div><div class="line">     <span class="keyword">this</span>.name=name;</div><div class="line">     <span class="keyword">this</span>.price=price; </div><div class="line">   &#125;</div><div class="line">    Car.prototype.sell=<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</div><div class="line">      alert(<span class="string">"我是"</span>+<span class="keyword">this</span>.name+<span class="string">"，我现在卖"</span>+<span class="keyword">this</span>.price+<span class="string">"万元"</span>);</div><div class="line">     &#125;</div><div class="line">   <span class="keyword">var</span> camry =<span class="keyword">new</span> Car(<span class="string">"凯美瑞"</span>,<span class="number">27</span>);</div><div class="line">   camry.sell();</div></pre></td></tr></table></figure>
<p><strong>Javascript作用链域?</strong></p>
<ul>
<li>全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节</li>
<li>当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找</li>
<li>直至全局函数，这种组织形式就是作用域链</li>
</ul>
<p><strong>谈谈This对象的理解</strong></p>
<ul>
<li>this总是指向函数的直接调用者（而非间接调用者）</li>
<li>如果有new关键字，this指向new出来的那个对象</li>
<li>在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window</li>
</ul>
<p><strong>eval是做什么的？</strong></p>
<ul>
<li>它的功能是把对应的字符串解析成JS代码并运行</li>
<li>应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）</li>
<li>由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval(‘(‘+ str +’)’)</li>
</ul>
<p><strong>null，undefined 的区别？</strong></p>
<ul>
<li>undefined   表示不存在这个值。</li>
<li>undefined :是一个表示”无”的原始值或者说表示”缺少值”，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined</li>
<li><p>例如变量被声明了，但没有赋值时，就等于undefined</p>
</li>
<li><p>null 表示一个对象被定义了，值为“空值”</p>
</li>
<li>null : 是一个对象(空对象, 没有任何属性和方法)</li>
<li><p>例如作为函数的参数，表示该函数的参数不是对象；</p>
</li>
<li><p>在验证null时，一定要使用　=== ，因为 == 无法分别 null 和　undefined</p>
</li>
</ul>
<p><strong>写一个通用的事件侦听器函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// event(事件)工具集，来源：github.com/markyun</span></div><div class="line">   markyun.Event = &#123;</div><div class="line">       <span class="comment">// 页面加载完成后</span></div><div class="line">       readyEvent : <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">           <span class="keyword">if</span> (fn==<span class="literal">null</span>) &#123;</div><div class="line">               fn=<span class="built_in">document</span>;</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">var</span> oldonload = <span class="built_in">window</span>.onload;</div><div class="line">           <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span>.onload != <span class="string">'function'</span>) &#123;</div><div class="line">               <span class="built_in">window</span>.onload = fn;</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                   oldonload();</div><div class="line">                   fn();</div><div class="line">               &#125;;</div><div class="line">           &#125;</div><div class="line">       &#125;,</div><div class="line">       <span class="comment">// 视能力分别使用dom0||dom2||IE方式 来绑定事件</span></div><div class="line">       <span class="comment">// 参数： 操作的元素,事件名称 ,事件处理程序</span></div><div class="line">       addEvent : <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</div><div class="line">           <span class="keyword">if</span> (element.addEventListener) &#123;</div><div class="line">               <span class="comment">//事件类型、需要执行的函数、是否捕捉</span></div><div class="line">               element.addEventListener(type, handler, <span class="literal">false</span>);</div><div class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</div><div class="line">               element.attachEvent(<span class="string">'on'</span> + type, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                   handler.call(element);</div><div class="line">               &#125;);</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               element[<span class="string">'on'</span> + type] = handler;</div><div class="line">           &#125;</div><div class="line">       &#125;,</div><div class="line">       <span class="comment">// 移除事件</span></div><div class="line">       removeEvent : <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</div><div class="line">           <span class="keyword">if</span> (element.removeEventListener) &#123;</div><div class="line">               element.removeEventListener(type, handler, <span class="literal">false</span>);</div><div class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.datachEvent) &#123;</div><div class="line">               element.detachEvent(<span class="string">'on'</span> + type, handler);</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               element[<span class="string">'on'</span> + type] = <span class="literal">null</span>;</div><div class="line">           &#125;</div><div class="line">       &#125;,</div><div class="line">       <span class="comment">// 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获)</span></div><div class="line">       stopPropagation : <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</div><div class="line">           <span class="keyword">if</span> (ev.stopPropagation) &#123;</div><div class="line">               ev.stopPropagation();</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               ev.cancelBubble = <span class="literal">true</span>;</div><div class="line">           &#125;</div><div class="line">       &#125;,</div><div class="line">       <span class="comment">// 取消事件的默认行为</span></div><div class="line">       preventDefault : <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">           <span class="keyword">if</span> (event.preventDefault) &#123;</div><div class="line">               event.preventDefault();</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               event.returnValue = <span class="literal">false</span>;</div><div class="line">           &#125;</div><div class="line">       &#125;,</div><div class="line">       <span class="comment">// 获取事件目标</span></div><div class="line">       getTarget : <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">           <span class="keyword">return</span> event.target || event.srcElement;</div><div class="line">       &#125;,</div><div class="line">       <span class="comment">// 获取event对象的引用，取到事件的所有信息，确保随时能使用event；</span></div><div class="line">       getEvent : <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">           <span class="keyword">var</span> ev = e || <span class="built_in">window</span>.event;</div><div class="line">           <span class="keyword">if</span> (!ev) &#123;</div><div class="line">               <span class="keyword">var</span> c = <span class="keyword">this</span>.getEvent.caller;</div><div class="line">               <span class="keyword">while</span> (c) &#123;</div><div class="line">                   ev = c.arguments[<span class="number">0</span>];</div><div class="line">                   <span class="keyword">if</span> (ev &amp;&amp; Event == ev.constructor) &#123;</div><div class="line">                       <span class="keyword">break</span>;</div><div class="line">                   &#125;</div><div class="line">                   c = c.caller;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">return</span> ev;</div><div class="line">       &#125;</div><div class="line">   &#125;;</div></pre></td></tr></table></figure>
<p><strong>[“1”, “2”, “3”].map(parseInt) 答案是多少？</strong></p>
<ul>
<li>[1, NaN, NaN] 因为 parseInt 需要两个参数 (val, radix)，其中 radix 表示解析时用的基数。</li>
<li>map 传了 3 个 (element, index, array)，对应的 radix 不合法导致解析失败。</li>
</ul>
<p><strong>事件是？IE与火狐的事件机制有什么区别？ 如何阻止冒泡？</strong></p>
<ul>
<li>我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为</li>
<li>事件处理机制：IE是事件冒泡、Firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件</li>
<li>ev.stopPropagation();（旧ie的方法 ev.cancelBubble = true;）</li>
</ul>
<p><strong>什么是闭包（closure），为什么要用它？</strong></p>
<ul>
<li><p>闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域</p>
</li>
<li><p>闭包的特性：</p>
<ul>
<li>函数内再嵌套函数</li>
<li>内部函数可以引用外层的参数和变量</li>
<li>参数和变量不会被垃圾回收机制回收</li>
</ul>
</li>
</ul>
<p><strong>javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？</strong></p>
<ul>
<li>use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为</li>
</ul>
<p><strong>如何判断一个对象是否属于某个类？</strong></p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用instanceof （待完善）</span></div><div class="line">   <span class="keyword">if</span><span class="comment">(a instanceof Person)</span>&#123;</div><div class="line">       alert<span class="comment">('yes')</span>;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p><strong>new操作符具体干了什么呢?</strong></p>
<ul>
<li>创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型</li>
<li>属性和方法被加入到 this 引用的对象中</li>
<li>新创建的对象由 this 所引用，并且最后隐式的返回 this</li>
</ul>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var obj  = &#123;&#125;<span class="comment">;</span></div><div class="line">obj.__proto__ = Base.prototype<span class="comment">;</span></div><div class="line">Base.call(obj)<span class="comment">;</span></div></pre></td></tr></table></figure>
<p><strong>js延迟加载的方式有哪些？</strong></p>
<ul>
<li>defer和async、动态创建DOM方式（用得最多）、按需异步载入js</li>
</ul>
<p><strong>Ajax 是什么? 如何创建一个Ajax？</strong></p>
<blockquote>
<p>ajax的全称：Asynchronous Javascript And XML</p>
</blockquote>
<ul>
<li>异步传输+js+xml</li>
<li><p>所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验</p>
</li>
<li><p>创建XMLHttpRequest对象,也就是创建一个异步调用对象</p>
</li>
<li>建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息</li>
<li>设置响应HTTP请求状态变化的函数</li>
<li>发送HTTP请求</li>
<li>获取异步调用返回的数据</li>
<li>用JavaScript和DOM实现局部刷新</li>
</ul>
<p><strong>同步和异步的区别?</strong></p>
<ul>
<li>同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作</li>
<li>异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容</li>
</ul>
<p><strong>异步加载JS的方式有哪些？</strong></p>
<ul>
<li>defer，只支持IE</li>
<li>async：</li>
<li>创建script，插入到DOM中，加载完毕后callBack</li>
</ul>
<p><strong>documen.write和 innerHTML的区别</strong></p>
<ul>
<li>document.write只能重绘整个页面</li>
<li>innerHTML可以重绘页面的一部分</li>
</ul>
<p><strong>DOM操作——怎样添加、移除、移动、复制、创建和查找节点?</strong></p>
<ul>
<li>（1）创建新节点<ul>
<li>createDocumentFragment() //创建一个DOM片段</li>
<li>createElement()   //创建一个具体的元素</li>
<li>createTextNode()   //创建一个文本节点</li>
</ul>
</li>
<li>（2）添加、移除、替换、插入<ul>
<li>appendChild()</li>
<li>removeChild()</li>
<li>replaceChild()</li>
<li>insertBefore() //在已有的子节点前插入一个新的子节点</li>
</ul>
</li>
<li>（3）查找<ul>
<li>getElementsByTagName()    //通过标签名称</li>
<li>getElementsByName()    // 通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)</li>
<li>getElementById()    //通过元素Id，唯一性</li>
</ul>
</li>
</ul>
<p><strong>那些操作会造成内存泄漏？</strong></p>
<ul>
<li>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在</li>
<li>垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收</li>
<li>setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏</li>
<li>闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</li>
</ul>
<p><strong>渐进增强和优雅降级</strong></p>
<ul>
<li><p>渐进增强 ：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</p>
</li>
<li><p>优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容</p>
</li>
</ul>
<p><strong>Javascript垃圾回收方法</strong></p>
<ul>
<li>标记清除（mark and sweep）</li>
</ul>
<blockquote>
<ul>
<li>这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”</li>
<li>垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了</li>
</ul>
</blockquote>
<p><strong>引用计数(reference counting)</strong></p>
<blockquote>
<p>在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间</p>
</blockquote>
<p><strong>js继承方式及其优缺点</strong></p>
<ul>
<li><p>原型链继承的缺点</p>
<ul>
<li>一是字面量重写原型会中断关系，使用引用类型的原型，并且子类型还无法给超类型传递参数。</li>
</ul>
</li>
<li><p>借用构造函数（类式继承）</p>
<ul>
<li>借用构造函数虽然解决了刚才两种问题，但没有原型，则复用无从谈起。所以我们需要原型链+借用构造函数的模式，这种模式称为组合继承</li>
</ul>
</li>
<li><p>组合式继承</p>
<ul>
<li>组合式继承是比较常用的一种继承方法，其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。</li>
</ul>
</li>
</ul>
<p><strong>defer和async</strong></p>
<ul>
<li>defer并行加载js文件，会按照页面上script标签的顺序执行async并行加载js文件，下载完成立即执行，不会按照页面上script标签的顺序执行</li>
</ul>
<p><strong>用过哪些设计模式？</strong></p>
<ul>
<li><p>工厂模式：</p>
<ul>
<li>主要好处就是可以消除对象间的耦合，通过使用工程方法而不是new关键字。将所有实例化的代码集中在一个位置防止代码重复</li>
<li>工厂模式解决了重复实例化的问题 ，但还有一个问题,那就是识别问题，因为根本无法 搞清楚他们到底是哪个对象的实例<br>-<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObject</span><span class="params">(name,age,profession)</span></span>&#123;<span class="comment">//集中实例化的函数var obj = new Object();</span></div><div class="line">    obj.name = name;</div><div class="line">    obj.age = age;</div><div class="line">    obj.profession = profession;</div><div class="line">    obj.move = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">' at '</span> + <span class="keyword">this</span>.age + <span class="string">' engaged in '</span> + <span class="keyword">this</span>.profession;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> obj;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> test1 = createObject(<span class="string">'trigkit4'</span>,<span class="number">22</span>,<span class="string">'programmer'</span>);<span class="comment">//第一个实例var test2 = createObject('mike',25,'engineer');//第二个实例</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>构造函数模式</p>
<ul>
<li>使用构造函数的方法 ，即解决了重复实例化的问题 ，又解决了对象识别的问题，该模式与工厂模式的不同之处在于</li>
</ul>
</li>
<li><p>构造函数方法没有显示的创建对象 (new Object());</p>
</li>
<li><p>直接将属性和方法赋值给 this 对象;</p>
</li>
<li><p>没有 renturn 语句</p>
</li>
</ul>
<p><strong>说说你对闭包的理解</strong></p>
<ul>
<li><p>使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念</p>
</li>
<li><p>闭包有三个特性：</p>
<ul>
<li><p>1.函数嵌套函数</p>
</li>
<li><p>2.函数内部可以引用外部的参数和变量</p>
</li>
<li><p>3.参数和变量不会被垃圾回收机制回收</p>
</li>
</ul>
</li>
</ul>
<p><strong>请解释一下 JavaScript 的同源策略</strong></p>
<ul>
<li>概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议</li>
<li>指一段脚本只能读取来自同一来源的窗口和文档的属性</li>
</ul>
<p><strong>为什么要有同源限制？</strong></p>
<ul>
<li>我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。</li>
<li>缺点<ul>
<li>现在网站的JS都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 merge后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节</li>
</ul>
</li>
</ul>
<p><strong>实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Object.prototype.clone = function()&#123;</div><div class="line"></div><div class="line">            <span class="keyword">var</span> o = <span class="keyword">this</span>.<span class="keyword">constructor</span> === Array ? [] : &#123;&#125;;</div><div class="line"></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> e <span class="keyword">in</span> <span class="keyword">this</span>)&#123;</div><div class="line"></div><div class="line">                    o[e] = typeof <span class="keyword">this</span>[e] === <span class="string">"object"</span> ? <span class="keyword">this</span>[e].clone() : <span class="keyword">this</span>[e];</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> o;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>说说严格模式的限制</strong></p>
<ul>
<li><p>严格模式主要有以下限制：</p>
</li>
<li><p>变量必须声明后再使用</p>
</li>
<li><p>函数的参数不能有同名属性，否则报错</p>
</li>
<li><p>不能使用with语句</p>
</li>
<li><p>不能对只读属性赋值，否则报错</p>
</li>
<li><p>不能使用前缀0表示八进制数，否则报错</p>
</li>
<li><p>不能删除不可删除的属性，否则报错</p>
</li>
<li><p>不能删除变量delete prop，会报错，只能删除属性delete global[prop]</p>
</li>
<li><p>eval不会在它的外层作用域引入变量</p>
</li>
<li><p>eval和arguments不能被重新赋值</p>
</li>
<li><p>arguments不会自动反映函数参数的变化</p>
</li>
<li><p>不能使用arguments.callee</p>
</li>
<li><p>不能使用arguments.caller</p>
</li>
<li><p>禁止this指向全局对象</p>
</li>
<li><p>不能使用fn.caller和fn.arguments获取函数调用的堆栈</p>
</li>
<li><p>增加了保留字（比如protected、static和interface）</p>
</li>
</ul>
<p><strong>如何删除一个cookie</strong></p>
<ul>
<li>将时间设为当前时间往前一点</li>
</ul>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">var</span> <span class="built_in">date</span> = <span class="literal">new</span> <span class="built_in">Date</span>();</div><div class="line"></div><div class="line"><span class="built_in">date</span>.setDate(<span class="built_in">date</span>.getDate() - <span class="number">1</span>);<span class="comment">//真正的删除</span></div></pre></td></tr></table></figure>
<p>setDate()方法用于设置一个月的某一天</p>
<ul>
<li>expires的设置</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.cookie = <span class="string">'user='</span>+ <span class="built_in">encodeURIComponent</span>(<span class="string">'name'</span>)  + <span class="string">';expires = '</span> + <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">0</span>)</div></pre></td></tr></table></figure>
<p><strong>编写一个方法 求一个字符串的字节长度</strong></p>
<ul>
<li>假设：一个英文字符占用一个字节，一个中文字符占用两个字节    </li>
</ul>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetBytes</span><span class="params">(str)</span></span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> len = str.length;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> bytes = len;</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (str.charCodeAt(i) &gt; <span class="number">255</span>) bytes++;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> bytes;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">alert(GetBytes(<span class="string">"你好,as"</span>));</div></pre></td></tr></table></figure>
<p><strong>请解释什么是事件代理</strong></p>
<ul>
<li>事件代理（Event Delegation），又称之为事件委托。是 JavaScript 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能</li>
</ul>
<p><strong>attribute和property的区别是什么？</strong></p>
<ul>
<li>attribute是dom元素在文档中作为html标签拥有的属性；</li>
<li><p>property就是dom元素在js中作为对象拥有的属性。</p>
</li>
<li><p>对于html的标准属性来说，attribute和property是同步的，是会自动更新的</p>
</li>
<li>但是对于自定义的属性来说，他们是不同步的</li>
</ul>
<p><strong>页面编码和被请求的资源编码如果不一致如何处理？</strong></p>
<ul>
<li>后端响应头设置 charset </li>
<li>前端页面<code>&lt;meta&gt;</code>设置 charset</li>
</ul>
<p><strong>把<code>&lt;script&gt;</code>放在<code>&lt;/body&gt;</code>之前和之后有什么区别？浏览器会如何解析它们？</strong></p>
<ul>
<li>按照HTML标准，在<code>&lt;/body&gt;</code>结束后出现<code>&lt;script&gt;</code>或任何元素的开始标签，都是解析错误</li>
<li>虽然不符合HTML标准，但浏览器会自动容错，使实际效果与写在<code>&lt;/body&gt;</code>之前没有区别</li>
<li>浏览器的容错机制会忽略<script>之前的<code>&lt;/body&gt;</code>，视作<code>&lt;script&gt;</code>仍在 body 体内。省略<code>&lt;/body&gt;</code>和<code>&lt;/html&gt;</code>闭合标签符合HTML标准，服务器可以利用这一标准尽可能少输出内容</li>
</ul>
<p><strong>延迟加载JS的方式有哪些？</strong></p>
<ul>
<li>设置<code>&lt;script&gt;</code>属性 defer=”defer” （脚本将在页面完成解析时执行）</li>
<li>动态创建 script DOM：document.createElement(‘script’);</li>
<li>XmlHttpRequest 脚本注入</li>
<li>延迟加载工具 LazyLoad</li>
</ul>
<p><strong>异步加载JS的方式有哪些？</strong></p>
<ul>
<li>设置<code>&lt;script&gt;</code>属性 async=”async” （一旦脚本可用，则会异步执行）</li>
<li>动态创建 script DOM：document.createElement(‘script’);</li>
<li>XmlHttpRequest 脚本注入</li>
<li>异步加载库 LABjs</li>
<li>模块加载器 Sea.js</li>
</ul>
<p><strong>JavaScript 中，调用函数有哪几种方式？</strong></p>
<ul>
<li>方法调用模式          Foo.foo(arg1, arg2);</li>
<li>函数调用模式          foo(arg1, arg2);</li>
<li>构造器调用模式        (new Foo())(arg1, arg2);</li>
<li>call/applay调用模式   Foo.foo.call(that, arg1, arg2);</li>
<li>bind调用模式          Foo.foo.bind(that)(arg1, arg2)();</li>
</ul>
<p><strong>简单实现 Function.bind 函数？</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.bind) &#123;</div><div class="line">  <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">that</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> func = <span class="keyword">this</span>, args = <span class="built_in">arguments</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> func.apply(that, <span class="built_in">Array</span>.prototype.slice.call(args, <span class="number">1</span>));</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 只支持 bind 阶段的默认参数：</span></div><div class="line">func.bind(that, arg1, arg2)();</div><div class="line"></div><div class="line"><span class="comment">// 不支持以下调用阶段传入的参数：</span></div><div class="line">func.bind(that)(arg1, arg2);</div></pre></td></tr></table></figure>
<p><strong> 列举一下JavaScript数组和对象有哪些原生方法？</strong></p>
<ul>
<li><p>数组：</p>
<ul>
<li>arr.concat(arr1, arr2, arrn);</li>
<li>arr.join(“,”);</li>
<li>arr.sort(func);</li>
<li>arr.pop();</li>
<li>arr.push(e1, e2, en);</li>
<li>arr.shift();</li>
<li>unshift(e1, e2, en);</li>
<li>arr.reverse();</li>
<li>arr.slice(start, end);            </li>
<li>arr.splice(index, count, e1, e2, en);  </li>
<li>arr.indexOf(el);</li>
<li>arr.includes(el);   // ES6</li>
</ul>
</li>
<li><p>对象：</p>
<ul>
<li>object.hasOwnProperty(prop);     </li>
<li>object.propertyIsEnumerable(prop);</li>
<li>object.valueOf();                 </li>
<li>object.toString();                </li>
<li>object.toLocaleString();          </li>
<li>Class.prototype.isPropertyOf(object);  </li>
</ul>
</li>
</ul>
<p><strong>Array.splice() 与 Array.splice() 的区别？</strong></p>
<ul>
<li><p>slice – “读取”数组指定的元素，不会对原数组进行修改</p>
<ul>
<li>语法：arr.slice(start, end)</li>
<li>start 指定选取开始位置（含）</li>
<li>end 指定选取结束位置（不含）</li>
</ul>
<ul>
<li>splice <ul>
<li>“操作”数组指定的元素，会修改原数组，返回被删除的元素</li>
<li>语法：arr.splice(index, count, [insert Elements])</li>
<li>index 是操作的起始位置</li>
<li>count = 0 插入元素，count &gt; 0 删除元素</li>
<li>[insert Elements] 向数组新插入的元素</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>JavaScript 对象生命周期的理解？</strong></p>
<ul>
<li>当创建一个对象时，JavaScript 会自动为该对象分配适当的内存</li>
<li>垃圾回收器定期扫描对象，并计算引用了该对象的其他对象的数量</li>
<li>如果被引用数量为 0，或惟一引用是循环的，那么该对象的内存即可回收</li>
</ul>
<p><strong>哪些操作会造成内存泄漏？</strong></p>
<ul>
<li><p>JavaScript 内存泄露指对象在不需要使用它时仍然存在，导致占用的内存不能使用或回收</p>
</li>
<li><p>未使用 var 声明的全局变量</p>
</li>
<li>闭包函数(Closures)</li>
<li>循环引用(两个对象相互引用)</li>
<li>控制台日志(console.log)</li>
<li>移除存在绑定事件的DOM元素(IE)</li>
</ul>
</script></li></ul>  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/JavaScript/">JavaScript</a>
  </div>


<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
</div>



<div class="article-share" id="share">

  <div data-url="http://adminlly.github.io/2017/05/10/JavaScript/" data-title="JavaScript 描述,语法 | 李刘玉的博客" data-tsina="" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2017/05/10/HTTP/" title="http状态码">
  <strong>PREVIOUS:</strong><br/>
  <span>
  http状态码</span>
</a>
</div>


<div class="next">
<a href="/2017/04/15/SEO/"  title="前端需要注意哪些SEO">
 <strong>NEXT:</strong><br/> 
 <span>前端需要注意哪些SEO
</span>
</a>
</div>

</nav>

	
</div>  
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">Contents</strong>
  <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript"><span class="toc-number">1.</span> <span class="toc-text">JavaScript</span></a></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
			<li><a href="/categories/CSS/" title="CSS">CSS<sup>1</sup></a></li>
		
			<li><a href="/categories/Cookie/" title="Cookie">Cookie<sup>1</sup></a></li>
		
			<li><a href="/categories/Css/" title="Css">Css<sup>1</sup></a></li>
		
			<li><a href="/categories/ES6/" title="ES6">ES6<sup>1</sup></a></li>
		
			<li><a href="/categories/HTML/" title="HTML">HTML<sup>1</sup></a></li>
		
			<li><a href="/categories/HTTP/" title="HTTP">HTTP<sup>1</sup></a></li>
		
			<li><a href="/categories/Hexo教程/" title="Hexo教程">Hexo教程<sup>1</sup></a></li>
		
			<li><a href="/categories/JSON/" title="JSON">JSON<sup>2</sup></a></li>
		
			<li><a href="/categories/JavaScript/" title="JavaScript">JavaScript<sup>1</sup></a></li>
		
			<li><a href="/categories/MVC/" title="MVC">MVC<sup>1</sup></a></li>
		
			<li><a href="/categories/PS/" title="PS">PS<sup>1</sup></a></li>
		
			<li><a href="/categories/SEO/" title="SEO">SEO<sup>1</sup></a></li>
		
			<li><a href="/categories/SPA/" title="SPA">SPA<sup>1</sup></a></li>
		
			<li><a href="/categories/ajax/" title="ajax">ajax<sup>1</sup></a></li>
		
			<li><a href="/categories/git/" title="git">git<sup>2</sup></a></li>
		
			<li><a href="/categories/github/" title="github">github<sup>2</sup></a></li>
		
			<li><a href="/categories/jQuery/" title="jQuery">jQuery<sup>2</sup></a></li>
		
			<li><a href="/categories/php/" title="php">php<sup>1</sup></a></li>
		
			<li><a href="/categories/服务器端模块化/" title="服务器端模块化">服务器端模块化<sup>1</sup></a></li>
		
			<li><a href="/categories/框架/" title="框架">框架<sup>1</sup></a></li>
		
			<li><a href="/categories/碎念/" title="碎念">碎念<sup>3</sup></a></li>
		
			<li><a href="/categories/跨域/" title="跨域">跨域<sup>1</sup></a></li>
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			<li><a href="/tags/CSS/" title="CSS">CSS<sup>1</sup></a></li>
		
			<li><a href="/tags/ES6/" title="ES6">ES6<sup>1</sup></a></li>
		
			<li><a href="/tags/HTML/" title="HTML">HTML<sup>1</sup></a></li>
		
			<li><a href="/tags/HTTP/" title="HTTP">HTTP<sup>1</sup></a></li>
		
			<li><a href="/tags/JS/" title="JS">JS<sup>3</sup></a></li>
		
			<li><a href="/tags/JavaScript/" title="JavaScript">JavaScript<sup>1</sup></a></li>
		
			<li><a href="/tags/PS/" title="PS">PS<sup>1</sup></a></li>
		
			<li><a href="/tags/SEO/" title="SEO">SEO<sup>2</sup></a></li>
		
			<li><a href="/tags/SPA/" title="SPA">SPA<sup>1</sup></a></li>
		
			<li><a href="/tags/ajax/" title="ajax">ajax<sup>1</sup></a></li>
		
			<li><a href="/tags/css/" title="css">css<sup>1</sup></a></li>
		
			<li><a href="/tags/css3/" title="css3">css3<sup>1</sup></a></li>
		
			<li><a href="/tags/es6/" title="es6">es6<sup>1</sup></a></li>
		
			<li><a href="/tags/git/" title="git">git<sup>3</sup></a></li>
		
			<li><a href="/tags/github/" title="github">github<sup>3</sup></a></li>
		
			<li><a href="/tags/jQuery/" title="jQuery">jQuery<sup>2</sup></a></li>
		
			<li><a href="/tags/php/" title="php">php<sup>1</sup></a></li>
		
			<li><a href="/tags/react-js/" title="react.js">react.js<sup>1</sup></a></li>
		
			<li><a href="/tags/服务器/" title="服务器">服务器<sup>1</sup></a></li>
		
		</ul>
</div>


  <div class="rsspart">
	<a href="" target="_blank" title="rss">RSS</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<div class="social-font clearfix">
		
		
		
		
		
	</div>
		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/A-limon/pacman" target="_blank" title="Pacman">Pacman</a> © 2018 
		
		<a href="http://adminlly.github.io" target="_blank" title="李刘玉">李刘玉</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>






  </body>
</html>
